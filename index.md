## 傻猪猪
### 计算实习题1（书P137第1题）

* #### **程序代码**

~~~matlab
function [ y ] = f( x )
%f为被求积分函数
y=sqrt(x)*log(x);

end
~~~
~~~matlab
function [ y ] = trapezium( n )
%trapezium（复合梯形）函数：
%   输入 - n是区间长度与步长的比值
%   输出 - y是用复合梯形公式求得的积分值
a=0.0000001;
b=1;
h=(b-a)/n;
y=h*(f(a)+(b))/2;
if n>1
    for k=1:n-1
        x=a+k*h;
        y=y+h*f(x);
    end
end

end
~~~
~~~matlab
function [ y ] = comSimpson( n )
%comSimpson（复合辛普森）函数：
%   输入 - n是区间长度与步长的比值
%   输出 - y是用复合辛普森公式求得的积分值
a=0.0000001;
b=1;
h=(b-a)/n;
y=h*(f(a)+(b))/6;
if n>1
    for k=0:n-1
        x0=a+(k+0.5)*h;
        x1=a+k*h;
        if k==0 
            y=y+4*f(x0)*h/6;
        else
            y=y+(4*f(x0)+2*f(x1))*h/6;
        end
    end
end

end
~~~
~~~matlab
function [ y ] = Romberg( k )
%Romberg（龙贝格）函数：
%   输入 - k是精度需求
%   输出 - y是龙贝格求积结果
a=0.0000001;
b=1;
R(1,1)=(b-a)*(f(a)+f(b))/2;
if k>0
    for i=1:k
        n=2^i;
        y=0;
        h=(b-a)/n;
        for j=0:n-1
            x=a+h*(j+0.5);
            y=y+h*f(x)/2;
        end
        R(i+1,1)=R(i,1)/2+y;
        for m=1:k
            R(i+1,m+1)=(4^m*R(i+1,m)-R(i,m))/(4^m-1);
        end
    end
end
y=R(k+1,k+1);

end
~~~
* #### **结果输出**
~~~matlab
%第一小问

%h1,h2分别储存随着步长不断减少复合梯形公式误差值与复合辛普森公式误差值
>> h1=zeros(1,199);
>> h2=zeros(1,199);
>> for n=2:200
h1(n-1)=trapezium(n)-(-4/9);
h2(n-1)=comSimpson(n)-(-4/9);
end

>> plot(h1)
>> hold on
>> plot(h2)
legend("复合梯形公式精度","复合辛普森公式精度")

~~~

![两种公式精度比较](http://oxtjshci8.bkt.clouddn.com/%E4%B8%A4%E7%A7%8D%E5%85%AC%E5%BC%8F%E7%B2%BE%E5%BA%A6%E6%AF%94%E8%BE%83.bmp)

复合梯形公式的余项为：$R_{n}(f)=-\frac{b-a}{12}h^2f^"(\eta),	\eta\in(a,b).$

复合辛普森公式的余项为：$R_{n}(f)=-\frac{b-a}{180}(\frac{h}{2})^4f^{(4)}(\eta),\eta\in(a,b).$

结论：不存在一个最小的$h$，使得精度不能再改善。

~~~matlab
%第二小问

%直接利用龙贝格函数
>> Romberg(5)

ans =

  -0.438786835776902
  
>> Romberg(10)

ans =

  -0.444291862957655

>> Romberg(15)

ans =

  -0.444439873182946
  
>> Romberg(20)

ans =

  -0.444444302425469
  
>> Romberg(25)

ans =

  -0.444444439665155
~~~

龙贝格积分公式的余项为：$I-T_{n}=-\frac{b-a}{12}h^2f^"(\eta),\eta\in[a,b],h=\frac{b-a}{n}.​$
~~~matlab
%第三小问
%用自适应辛普森积分，使精度达到10^-4

%直接利用matlab内置quad函数
>> F=@(x)sqrt(x).*log(x);
>> quad(F,0,1,10^-4)

ans =

  -0.443975572951728
~~~

*注释：*

> `quad`（Numerically evaluate integral, adaptive Simpson quadrature）：*Quadrature* is a numerical method used to find the area under the graph of a function, that is, to compute a definite integral.
>
> $q=\int_{a}^{b}f(x)dx$
>
> `q = quad(fun,a,b,tol)` uses an absolute error tolerance `tol` instead of the default which is `1.0e-6`. Larger values of `tol` result in fewer function evaluations and faster computation, but less accurate results. In MATLAB® version 5.3 and earlier, the `quad` function used a less reliable algorithm and a default relative tolerance of `1.0e-3`.

### 计算实习题2（书P239第1题第(2)问）

* #### **程序代码**

~~~matlab
function [ k,xk,yk,p ] = Stephens( x0,tol,ddmax, fun )
%Stephens（斯特芬森迭代）函数：
%   输入 - x0是起始点
%        - tol是精度要求
%        - ddmax是限制的最大迭代次数
%        - fun是迭代函数
%   输出 - k是迭代次数
%        - xk是近似根
%        - yk是近似根
%        - p可以展现迭代过程
x(1)=x0;
for i=1:ddmax
    x1(i+1)=fun(x(i));
    x2(i+1)=fun(x1(i+1));
    x(i+1)=x2(i+1)-(x2(i+1)-x1(i+1))^2/(x2(i+1)-2*x1(i+1)+x(i));
    dev=abs(x(i+1)-x(i));
    xdev=dev/(abs(x(i+1))+eps);
    i=i+1;
    xk=x(i);yk=fun(x(i));
    if(dev<tol)|(xdev<tol)
        k=i-1;
        xk=x(i);yk=fun(x(i));
        m=[0,1:i-1];
        p=[m',x1',x2',x'];
        return;
    end
end
if i>ddmax
    disp('迭代次数超过给定的最大值ddmax')
    k=i-1;
    xk=x(i);yk=fun(x(i));
    m=[0,1:i-1];
    p=[m',x1',x2',x'];
    return;
end
m=[0,1:i-1];
p=[m',x1',x2',x'];

end
~~~
~~~matlab
function [ k,xk,yk,dev,xdev ] = Newton( x0,tol,ftol,gxmax,fun,dfun )
%Newton（牛顿迭代）函数：
%   输入 - x0是起始点
%        - tol是精度要求
%        - ftol是精度要求
%        - gxmax是限制的最大迭代次数
%        - fun是迭代函数
%        - dfun是迭代函数的导数
%   输出 - k是迭代次数
%        - xk是近似根
%        - dev,xdev是误差
x(1)=x0;
for i=1:gxmax
    x(i+1)=x(i)-fun(x(i))/(dfun(x(i))+eps);
    dev=abs(x(i+1)-x(i));
    xdev=dev/(abs(x(i+1))+eps);
    i=i+1;
    xk=x(i);yk=fun(x(i));
    [(i-1) xk yk dev xdev]
    if(abs(yk)<ftol)&((dev<tol)|(xdev<tol))
        k=i-1;
        xk=x(i);
        [(i-1) xk yk dev xdev]
        return;
    end
end
if i>gxmax
    disp('迭代次数超过给定的最大值gxmax')
    k=i-1;
    xk=x(i);
    [(i-1) xk yk dev xdev]
    return;
end
[(i-1) xk yk dev xdev]'

end
~~~
* #### **结果输出**

第一小问：

不动点迭代法：在尝试许多种不同的迭代函数后，仍然没有找到能直接使迭代序列收敛的函数。

第二小问（斯特芬森加速迭代）：

~~~matlab
>> fun=inline('(-x^3-2*x^2+20)/10','x');
>> [k,xk,yk,p]=Stephens(3/2,1e-8,100,fun)

k =

     4


xk =

   1.368808107821373


yk =

   1.368808107821373


p =

  1 至 3 列

                   0                   0                   0
   1.000000000000000   1.212500000000000   1.527712304687500
   2.000000000000000   1.375387148078220   1.361481453696835
   3.000000000000000   1.368820676621146   1.368794161209545
   4.000000000000000   1.368808107867100   1.368808107770633

  4 列

   1.500000000000000
   1.362859527908831
   1.368796780568047
   1.368808107780163
   1.368808107821373
~~~

第三小问（牛顿迭代）：

~~~matlab
>> syms x;
>> f=x^3+2*x^2+10*x-20;
>> fun=matlabFunction(f);
>> dfun=matlabFunction(diff(f));
>> [ k,xk,yk,dev,xdev ]=Newton(3/2,1e-8,1e-8,100,fun,dfun)
%以下为各次迭代值
xk =

   1.373626373626374


xk =

   1.368814819623964


xk =

   1.368808107834412


xk =

   1.368808107821373


xk =

   1.368808107821373

%k为迭代次数
k =

     4


xk =

   1.368808107821373


yk =

    -3.552713678800501e-15


dev =

     1.303956942422246e-11


xdev =

     9.526221644739196e-12
~~~

可以看出，斯特芬森加速迭代和牛顿迭代方法在本题中都只需要迭代4次，很难说两种方法孰优孰劣。不过，这可能与初始点的选择有关。当初始点的选择偏离根较远的时候，两种方法的优劣性能更加凸显。

### 计算实习题3（书P240第2题第(2)问）

这里的实验环境是Matlab 2017a，其他版本的也许会有不同。

* #### **代码论证**
~~~matlab
>> syms x
>> p=(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)*(x-8)*(x-9)*(x-10);
>> pp=matlabFunction(p);
>> e1=1e-6;e2=1e-8;e3=1e-10;

%利用solve函数解扰动方程

>> solve(p+e1*x^9==0,x)
 
ans =
 
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 1)
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 2)
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 3)
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 4)
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 5)
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 6)
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 7)
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 8)
  root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 9)
 root(z^10 - (54999999*z^9)/1000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 10)

>> s1=solve(p+e1*x^9==0,x);
>> vpa(s1)
 
ans =
 
 1.0000000000027557319224884189413
 1.9999999873015883042146885855943
 3.0000019526941774966077488208862
 3.99993932907127034518201302401
 5.0006790904997270024297168898267
 5.9965165544939005034340975614817
 7.0094011605732436894759588064807
 7.9866873531378921095620413736009
 9.0095440862848960246242113869939
 9.9972294859405487925470351321844
 
>> solve(p+e2*x^9==0,x)
 
ans =
 
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 1)
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 2)
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 3)
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 4)
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 5)
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 6)
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 7)
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 8)
  root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 9)
 root(z^10 - (5499999999*z^9)/100000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 10)

>> s2=solve(p+e2*x^9==0,x);
>> vpa(s2)
 
ans =
 
 1.0000000000000275573192239948736
 1.9999999998730158731161357663569
 3.0000000195267872748733470000881
 3.9999993931862407582708726445087
 5.0000067817760125198556867541871
 5.9999650095916069919718811434399
 7.0000934169668178605717770282118
 7.9998668480588456193661273332509
 9.0000960798048712800337997546762
 9.9999724412157742646211485804067

>> solve(p+e3*x^9==0,x)
 
ans =
 
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 1)
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 2)
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 3)
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 4)
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 5)
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 6)
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 7)
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 8)
  root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 9)
 root(z^10 - (549999999999*z^9)/10000000000 + 1320*z^8 - 18150*z^7 + 157773*z^6 - 902055*z^5 + 3416930*z^4 - 8409500*z^3 + 12753576*z^2 - 10628640*z + 3628800, z, 10)
 
>> s3=solve(p+e3*x^9==0,x);
>> vpa(s3)
 
ans =
 
 1.0000000000000002755731922398598
 1.9999999999987301587301687564338
 3.0000000001952678572989158869579
  3.999999993931851957409458425595
 5.0000000678168494760276938077996
 5.9999996500801591770432098846882
 7.0000009341118569365631703455024
 7.9999986684749776197920704826472
 9.0000009608636452685292655351144
 9.9999997244266612730328546354016
 
%利用roots函数解扰动方程

>> a=sym2poly(p);
>> a1=a;a2=a;a3=a;
>> a1(2)=a(2)+e1;
>> a2(2)=a(2)+e2;
>> a3(2)=a(2)+e3;

>> roots(a1)

ans =

   9.997229485882217
   9.009544086647395
   7.986687352259036
   7.009401161586829
   5.996516553903716
   5.000679090662802
   3.999939329062761
   3.000001952690503
   1.999999987301977
   1.000000000002757

>> roots(a2)

ans =

   9.999972440924401
   9.000096081232288
   7.999866845149838
   7.000093420128638
   5.999965007638402
   5.000006782451866
   3.999999393064947
   3.000000019537204
   1.999999999872371
   1.000000000000057
   
>> roots(a3)

ans =

   9.999999724517833
   9.000000960302860
   7.999998669833532
   7.000000932419527
   5.999999651253368
   5.000000067362279
   3.999999994025772
   3.000000000185624
   1.999999999999256
   0.999999999999987

%利用fzero函数解扰动方程

>> pp1=matlabFunction(pp+e1*x^9);
>> pp2=matlabFunction(pp+e2*x^9);
>> pp3=matlabFunction(pp+e3*x^9);

>> R1=zeros(10,1);
>> for i=1:10
R1(i)=fzero(pp1,i);
end
>> R1

R1 =

   1.000000000002756
   1.999999987301588
   3.000001952694178
   3.999939329071271
   5.000679090499727
   5.996516554493900
   7.009401160573244
   7.986687353137892
   9.009544086284896
   9.997229485940549
   
>> R2=zeros(10,1);
>> for i=1:10
R2(i)=fzero(pp2,i);
end
>> R2

R2 =

   1.000000000000028
   1.999999999873016
   3.000000019526787
   3.999999393186241
   5.000006781776013
   5.999965009591607
   7.000093416966818
   7.999866848058846
   9.000096079804871
   9.999972441215775
   
>> R3=zeros(10,1);
>> for i=1:10
R3(i)=fzero(pp3,i);
end
>> R3

R3 =

   1.000000000000000
   1.999999999998730
   3.000000000195268
   3.999999993931852
   5.000000067816850
   5.999999650080160
   7.000000934111857
   7.999998668474977
   9.000000960863645
   9.999999724426662
~~~

* #### **结果分析**
  通过matlab返回结果可以看出，`solve`函数并未给出数值解，而是通过`root`函数表示出了有10个解。而`roots`和`fzero`则给出了方程的数值解，但这两个方法给出的数值解却不尽相同。

  #####roots#####

  让我们首先来谈谈`roots`。`roots`函数需要的参数为多项式的系数，并且通过数组的形式输入。通过调取`roots`函数定义文件可以发现（见行内注释）：

  ~~~matlab
  %roots.m
  %······（省略了前面的部分）
  %   Copyright 1984-2008 The MathWorks, Inc.

  % ROOTS finds the eigenvalues of the associated companion matrix.

  if size(c,1)>1 && size(c,2)>1
      error(message('MATLAB:roots:NonVectorInput'))
  end

  if ~all(isfinite(c))
      error(message('MATLAB:roots:NonFiniteInput'));
  end

  c = c(:).';
  n = size(c,2);
  r = zeros(0,1,class(c));  

  inz = find(c);
  if isempty(inz),
      % All elements are zero
      %判断输入的元素是否都为0
      return
  end

  % Strip leading zeros and throw away.  
  % Strip trailing zeros, but remember them as roots at zero.
  %丢弃数组首端的0元素，统计数组尾端的0元素，并将相应的0记为根
  nnz = length(inz);
  c = c(inz(1):inz(nnz));
  r = zeros(n-inz(nnz),1,class(c));  

  % Prevent relatively small leading coefficients from introducing Inf
  % by removing them.
  %舍去相对来说很小的最高次项系数
  d = c(2:end)./c(1);
  while any(isinf(d))
      c = c(2:end);
      d = c(2:end)./c(1);
  end

  % Polynomial roots via a companion matrix
  %用伴随矩阵求解根
  n = length(c);
  if n > 1
      a = diag(ones(1,n-2,class(c)),-1);
      a(1,:) = -d;
      r = [r;eig(a)];
  end
  ~~~

  到这里`roots`函数的原理已经基本清楚了，在做了几项准备工作之后，它通过构造一个伴随矩阵的方法来求根。因为这个伴随矩阵的特征值就是原多项式的根，而特征值可以用`eig`函数求得。遗憾的是，当我查看`eig.m`文件时，发现里面只有寥寥几十行注释文本，并没有相关的代码文本。但是我猜想可能用的是常见的特征值分解的数值方法，例如QR分解一类的。

  #####fzero#####

    `fzero`求根分为两个阶段。第一个阶段根据给出的`x0`确定一个区间，区间两端的函数值符号相反；第二个阶段在该区间中求方程的根。根据`fzero.m`文件，它通过由`x0`向两边扩展，直到扩展的两段函数值反号即可。由`    ...% Choose bisection or interpolatio...`和`...output.algorithm = 'bisection, interpolation'...`可以看出，`fzero`之后再利用二分法或插值法找到根的数值解。

  #####solve#####

  `solve`对于高阶多项式等式经常只能输出`root`形式的解，之后再利用`vpa`函数求得数值逼近解。然后可以发现，该数值逼近解和`roots`求得的解在数字上是相同的（基于给出的位数判断）。所以，`solve`对于高阶多项式等式的解用`vpa`函数进行数值逼近的过程和`roots`函数的求解过程是相似甚至相同的。

---

**林嘉恒 15级信息与计算科学 2015111429**
